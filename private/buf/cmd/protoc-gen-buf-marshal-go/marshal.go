// Copyright 2020-2022 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package marshal

import (
	"context"
	"errors"
	"flag"
	"fmt"

	"github.com/bufbuild/buf/private/bufpkg/bufmodule/bufmoduleref"
	"github.com/bufbuild/buf/private/pkg/app/appproto"
	"github.com/bufbuild/buf/private/pkg/protogenutil"
	"google.golang.org/protobuf/compiler/protogen"
)

const (
	protoPackage = protogen.GoImportPath("google.golang.org/protobuf/proto")

	// TODO: We should depend on a go.buf.build import paths by default, but
	// make them configurable.
	reflectPackage = protogen.GoImportPath("github.com/bufbuild/buf/private/gen/proto/go/buf/alpha/reflect/v1alpha1")
)

var (
	flags     flag.FlagSet
	bufModule = flags.String("buf_module", "", "The module reference encoded in the descriptor")
)

// Main is the main.
func Main() {
	appproto.Main(
		context.Background(),
		protogenutil.NewPerFileHandler(
			handle,
			protogenutil.HandlerWithOptionHandler(flags.Set),
		),
	)
}

func handle(plugin *protogen.Plugin, file *protogen.File) error {
	if *bufModule == "" {
		return errors.New("protoc-gen-buf-marshal-go: a fully qualified module reference is required")
	}
	moduleReference, err := bufmoduleref.ModuleReferenceForString(*bufModule)
	if err != nil {
		return fmt.Errorf("protoc-gen-buf-marshal-go: %w", err)
	}
	if !bufmoduleref.IsCommitModuleReference(moduleReference) {
		return errors.New("protoc-gen-buf-marshal-go: module must reference a specific commit")
	}
	if len(file.Messages) == 0 {
		// For now, we only support files with messages. We might need to extend
		// this to enums later, but it probably isn't that useful in practice.
		return nil
	}
	filename := file.GeneratedFilenamePrefix + ".marshal.pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-buf-encoder-go. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	for _, message := range file.Messages {
		g.P("func (x *", message.GoIdent, ") MarshalWithDescriptorInfo() ([]byte, error) {")
		g.P("bytes, err := ", protoPackage.Ident("Marshal(x)"))
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("descriptorInfoBytes, err := ", protoPackage.Ident("Marshal"), "(")
		g.P("&", reflectPackage.Ident("Reflector"), "{")
		g.P("DescriptorInfo: ", "&", reflectPackage.Ident("DescriptorInfo"), "{")
		g.P("ModuleInfo: ", "&", reflectPackage.Ident("ModuleInfo"), "{")
		g.P("Name: ", "&", reflectPackage.Ident("ModuleName"), "{")
		g.P(`Remote: "`, moduleReference.Remote(), `",`)
		g.P(`Owner: "`, moduleReference.Owner(), `",`)
		g.P(`Repository: "`, moduleReference.Repository(), `",`)
		g.P("},")
		g.P(`Commit: "`, moduleReference.Reference(), `",`)
		g.P("},")
		g.P(`TypeName: "`, file.Proto.GetPackage(), ".", message.GoIdent.GoName, `",`) // TODO: Is GoName always right here?
		g.P("},")
		g.P("},")
		g.P(")")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("return append(bytes, descriptorInfoBytes...), nil")
		g.P("}")
		g.P()
	}
	return nil
}
